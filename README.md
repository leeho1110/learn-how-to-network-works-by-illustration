### 개요

Gene의 '그림으로 배우는 네트워크 원리'를 읽고 정리한 레포지토리입니다.

---

### 서평

백엔드 개발자는 단순히 서버 애플리케이션 개발자만을 뜻하지는 않습니다. 견고한 애플리케이션 설계 및 구현을 위해서는 클라이언트 요청이 서버로 어떻게 도달하는지를 이해해야 합니다. 이를 위해 컴퓨터 네트워크의 이해는 필수적입니다.

OSI 7계층으로 추상화되어 있는 각 레이어가 실제로 어떻게 구현되어 있는지와 클라이언트의 요청, 도달의 과정을 이해하기 위해 위 서적을 선택했습니다. 딥다이브보단 네트워크가 왜 필요한지부터 시작해서 레이어별 특성과 사용되는 프로토콜에 대해서 설명합니다. 

컴퓨터 네트워크에 대해서 학습 방향을 잡기 어렵거나 “나 네트워크 너무 모르는데,,? 얼른 배워야겠다” 라고 생각이 드신다면 추천드립니다. 길지 않고 중요 핵심을 학습하기 좋습니다. 

---

### Q&A

- *********Q. 네트워크는 모두가 이용할 수 있습니다. 인터넷은 어떻게 나눠져 있을까요?*********
    
    인터넷은 LAN(Local Area Network)와 이를 묶은 WAN(Wide Area Network)으로 이루어져 있습니다. 수많은 LAN, WAN들이 모여 거대한 Inter Network(인터넷)을 만듭니다.
    
    - ***Q. 인터넷을 구성하는 네트워크 중 ‘특히’ 거대한 네트워크들과 이를 제공하는 조직을 무엇이라고 할까요?***
        
        인터넷은 네트워크들이 묶인 거대한 네트워크라고 얘기했습니다. 그 중 기관이나 단체가 독립적으로 운영하는 네트워크가 존재하는데요. 이를 질문에선 ‘특히’ 거대한 네트워크라고 표현했고 이를 **AS(Autonomous System)** 라고 부릅니다.
        
        이를 제공하는 조직을 우리는 ISP(Internet Service Provider)라고 부릅니다. ISP들은 우리가 일반적으로 알고 있는 프로토콜과는 달리 **BGP(Boarder Gateway Protocol)** 로 연결되어 있습니다.
        
        - ***Q. ISP의 레벨에 대해서 설명해주세요.***
            
            ISP들도 결국은 독립된 운영하는 네트워크를 보유하는 것이기 때문에 연결이 필요하며 규모에 따라 레벨이 분리됩니다. Tier별로 1부터 3까지 계층화되어 있으며 대륙간 네트워크 연결은 Tier1이 담당하며 내부적으로 2,3 순으로 나눠집니다.
            
        - ***Q. 최근 이슈가 된 망 사용료에 대해 설명해주세요.***
            
            기존 인터넷은 접속료 개념이었습니다. 즉 접속을 허용받기 위한 요금만 지불하고 사용량에 따른 금액 책정은 이뤄지지 않았습니다. 예를 들어 SPOTV를 보고 싶다면 월 19,800원의 접속 허용료를 지불하고 마음껏 시청합니다. 우리가 12시간을 보든 2시간만 보든 요금이 달라지지 않습니다. 
            
            하지만 망 사용료는 접속료가 아닌 사용량에 따른 과금을 말합니다. 2시간 시청에는 19,800*2=39,800원을 지불하고 12시간 시청에는 19,800 * 12 = 237,600원을 지불하는 형식입니다.
            
- *********Q. 네트워크에서 오가는 트래픽은 물리 신호입니다. 이들은 어떻게 디지털 신호로 변환되는 걸까요?*********
    
    물리 신호가 디지털 신호로 변경되는 곳은 바로 네트워크 인터페이스입니다. 일반적으로 유선 네트워크 인터페이스로는 **이더넷(Ethernet)** 을 사용합니다.
    
    - ***Q. 하나의 네트워크에는 여러 호스트가 존재하고 이들은 각자만의 네트워크 인터페이스가 존재할텐데요. 어떻게 찾을 수 있을까요?***
        
        네트워크 인터페이스는 **MAC 주소**라는 고유 식별자가 존재합니다. 16진수로 표현되며 총 6쌍의 자리, 48비트로 표현됩니다. 앞의 3쌍(24비트)은 이더넷 인터페이스 제조사 코드(OUI, Organizational Unique Identifier), 뒤의 3쌍(24비트)은 제조사의 제품별 시리얼 번호입니다.
        
    - ***Q. 이더넷(L2)을 통해 변환된 데이터는 어떤 정보들을 갖고 있을까요?***
        
        레이어를 타고 올라가는 데이터들은 각 프로토콜에 필요한 정보들로 이뤄져 있습니다. 이를 우린 **제어 정보**라고 부르며 **헤더**에 담아 상위 레이어로 전송합니다.
        
        이더넷의 경우 데이터의 오류를 판단하기 위한 Frame Check Sequence(FCS)와 이더넷 헤더가 붙습니다. 이 때 이더넷의 페이로드에는 상위 레이어의 제어 정보들, 즉 각 층의 헤더들이 들어있습니다.
        
        - ***Q. 이렇게 상위 헤더들을 하위 레이어의 본문으로 감싸 전송하는 것을 뭐라고 부를까요?***
            
            **캡슐화** 라고 부릅니다. 또한 각 레이어마다 이런 헤더들을 부르는 명칭과 정보, 이러한 데이터를 부르는 단위까지 모두 다릅니다. 
            
            우리가 흔히 알고 있는 IP 패킷, HTTP 메시지 외에도 TCP의 세그먼트, UDP의 데이터그램, 이더넷의 프레임까지 다양합니다. 이 중 패킷은 최대 1500바이트만큼의 크기를 가질 수 있는데요. 이를 **Maximum transmission unit, MTU** 라고 부릅니다. MTU는 앞서 말했던 세그먼트의 Maximum segment size, MSS 표준 1460바이트에 **TCP 헤더 20바이트, IP 헤더 20바이트를 더한 값**입니다.
            
    - ***Q. 네트워크는 어떤 기준으로 식별할 수 있을까요?***
        
        일반적으로는 **L2 스위치로 묶여있는 범위와 라우터** 를 하나의 네트워크로 규정할 수 있습니다. 그 이유는 라우터가 호스트들이 묶여있는 네트워크를 다른 네트워크와 통신할 수 있는 **라우팅 기능**을 제공하기 때문입니다. 이 때 다른 네트워크과의 통신을 위해 필요한 계층이 바로 **L3, 인터넷 계층** 입니다.
        
- *********Q. L3 인터넷 계층에선 어떻게 다른 네트워크와 통신하는 걸까요?*********
    - 인터넷 계층에선 통신하고자 하는 호스트를 **IP Address**를 통해 식별하며 I**nternet Protocol, IP**를 사용하는 라우터를 통해 통신합니다.
        - ***Q. IP Address는 어떻게 구성되어 있을까요?***
            
            IP는 32비트로 나눠져 있으며 네트워크부와 호스트부로 구성되어 있습니다. 가변적인 영역을 취하며 이를 표시하기 위해 서브넷 마스크를 사용합니다. 
            
            서브넷 마스크는 0과 1을 사용해 각 부분을 나타내기 때문에 IP Address까지 표현하진 못합니다. 이둘을 동시에 표기해 단점을 보완하는 **CIDR 표기법**이 존재합니다.
            
        - ***Q. 결국 IP Address도 네트워크 인터페이스를 통해 물리 신호가 디지털 신호로 변환되어야 합니다. 어떻게 찾을까요?***
            
            맞습니다. IP Address는 L3 인터넷 계층에서 사용되는 식별자입니다. 따라서 실제 신호가 도착하기 위해선 네트워크 인터페이스 식별자가 필요합니다.
            
            이 때 사용하는 프로토콜이 바로 **ARP(Address Resoultion Protocol)** 입니다. ARP 프로토콜을 사용해 IP Address와 Mac 주소를 매핑시키는 것을 주소 해석이라고 부릅니다.
            
            ARP는 IP 패킷 송신 시 목적지 IP 주소를 지정할 때 수행되며 동일 물리 네트워크 안의 호스트들에게 브로드캐스트를 사용합니다.
            
        - *********Q. 라우팅에 대해 설명해주세요.*********
            
            다른 네트워크로 데이터를 이동시키는 작업을 **라우팅**이라고 부릅니다. 이 때 필요한 것이 바로 라우터입니다. 라우터는 목적지 네트워크까지 도착 경로를 IP로 찾습니다. 
            
            라우팅은 자신이 연결된 네트워크에서 전달받은 IP 패킷을 수신하는 것부터 시작됩니다. IP 헤더를 열어 목적지 주소를 확인하고 **라우팅 테이블에서 어떤 네트워크(넥스트 홉)으로 보낼지 결정합**니다. 넥스트 홉으로 패킷을 전송할 때 우리는 무한순환을 막기 위해 헤더에 담긴 **Time To Live 값을 1씩 감소**시켜 줍니다. 
            
            이를 결정했다면 이더넷을 통해 데이터를 옮겨야 합니다. 이 때 수신 시 패킷에 달렸던 이더넷 헤더와 FCS를 교체합니다. 목적지 MAC 주소를 얻기 위해 위에서 언급한 ARP 프로토콜을 사용합니다.
- ***Q. TCP란 무엇일까요?***
  
    TCP는 Transmission Control Protocol의 약자로 '전송 제어 프로토콜'을 의미합니다. OSI Model에서는 4번째, TCP/IP Model에서는 2번째 계층에 해당됩니다. 두 모델 모두 E2E 통신을 위한 인터넷 계층(Internet Protocl)의 바로 위 계층에 위치해 있습니다. 엔드포인트는 호스트를 표현하는 단위이기에, 호스트 내 어떤 애플리케이션이 통신을 진행중인지는 알 수 없는 점을 보완합니다. 또한 데이터 전송 시 데이터를 전송하기만 할 뿐, 실제로 도착했는지 그리고 올바른 순서로 도착했는지는 보장하지 않는 Best effort한 특징을 갖습니다. TCP 계층은 호스트에게 [1] 전달된 데이터를 올바르게 도착할 수 있도록 하며, 각 애플리케이션에 적절하게 배분하는 역할을 수행합니다.

    인터넷 계층을 통한 IP 탐색 이후 [2] 호스트간 데이터 전달을 위한 커넥션을 생성하는 역할도 담당합니다. 커넥션이 생성된 뒤 데이터를 전송하는 과정에서 TCP는 reliable network를 보장하기 위해 몇 가지 역할을 더 담당하는데요.

    바로 전송 시 송신자와 수신자의 데이터 처리 속도가 상이할 경우 발생하는 문제를 처리하기 위한 [3] 흐름 제어, 네트워크 혼잡(Congestion)이 발생할 경우를 대비하기 위한 [4] 혼잡 제어 입니다.

    - ***Q. TCP Header는 어떻게 이뤄져 있을까요?***

      TCP는 데이터를 전송, 배분, 문제 상황 제어 등의 역할을 담당합니다. 이 때 각 역할을 수행하기 위해 여러 정보가 필요한데요. 이러한 정보를 담은 것을 TCP Header라고 부르며, TCP Header가 추가된 HTTP 메시지는 `TCP 세그먼트`라고 부릅니다.     세그먼트는 애플리케이션을 식별하기 위한 **`Port Number(16bit)`**, 전달하고자 하는 데이터가 어떻게 분할됐는지를 표현하는 **`Sequence Number`**,  데이터가 정상적으로 수신되었음을 확인하는 **`Acknowledgment number(if ACK set)`** 등을 담고 있습니다.

      아래는 [위키피디아: 전송 제어 프로토콜](https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C)에서 참조한 TCP Header의 시각화된 이미지입니다.

      ![image](https://user-images.githubusercontent.com/62372281/209471646-1e0dd112-eca7-4ef6-9146-90b6b6161685.png)

- ***Q. TCP는 왜 필요할까요?***
    
    이더넷과 IP를 통해서 데이터가 도착했다면 스트림을 통해 전달해야 합니다. 이 때 **양쪽 호스트를 연결하고 데이터를 온전하게 전달해주는 역할**을 수행해줍니다. 이를 위해선 연결을 수립하고 해제하는데 몇 가지 프로세스가 필요한데요. 티키타카의 횟수에 따라 연결을 맺을 때는 **3 way**, 끊을 때는 **4 way handshake**라고 부릅니다.

    - ***Q. TCP Connection이란 무엇일까요?***

      TCP는 reliable network를 보장하는 프로토콜입니다. 이 때 각 애플리케이션이 연결을 수립한 뒤 이를 통해 **데이터가 온전하고 올바른 순서로 도착함을 보장하는 '연결 상태'** 를 나타내는 논리적 개념이 바로 `TCP Connection` 입니다.

       TCP Connection 내에선 reliable함을 보장하기 위해서 데이터가 온전히 도착할 때까지 재전송하는 오류 처리 메커니즘이 적용되는데 이를**PAR(Positive Acknowledgement with Re-transmission)** 이라고 합니다.
    
       이러한 `TCP Connection`을 수립하고 소멸시킬 때 필요한 행위가 바로 **3way(establish) & 4way(close) handshake**입니다.
    
       > TCP는 Connection-oriented protocol(ex. 휴대폰 통화)이지만,
       > 데이터 전송의 무결성을 보장하지 않는 UDP는 Connection-less protocol(ex. 우편)입니다 😅

    - ***Q. 3 way handshake의 과정에 대해 설명해주세요.***

        3way handshake는 TCP Connection 수립을 위해서 **SYN 비트 세그먼트**를 활용합니다.

        <p align="center"><img src="https://user-images.githubusercontent.com/62372281/209475405-8dad1a99-fbec-4600-9ab4-30475c897f7f.png"></p>

        1. 두 디바이스 중 데이터를 요청하는 Client(C)가 Server(S)에게 연결을 수립하기 위해 **`SYN 비트 세그먼트`를 전송**합니다.
            - TCP Header의 Flags에 `SYN` 비트가 표시됩니다.
            - 이 후 C는 `SYN-SENT` 상태가 됩니다.
            - Sequence Number는 세션 하이재킹과 같은 보안 공격을 방지하기 위해 랜덤하게 생성된 Initial sequence number(ISN)로부터 지정됩니다.

        2. `SYN 비트 세그먼트`를 받은 S는 온전하게 전달 받았음을 표현하기 위해 **`SYN+ACK 비트 세그먼트`를 회신**합니다.
            - TCP Header의 Flags에는 `SYN`, `ACK` 비트가 표시됩니다.
            - 이 후 S는 `SYN-RECEIVED` 상태가 됩니다.
            - Acknowledgement Number는 1번에서 **C에게 전달받은 값에 1을 더한 값**이 담깁니다.
            - Sequence Number는 S측 ISN이 담깁니다.

        3. `SYN+ACK 비트 세그먼트`를 받는 C는 온전하게 전달 받았음을 표현하기 위해 **`ACK 비트 세그먼트`를 회신**합니다.
            - TCP Header의 Flags에 `ACK` 비트가 표시됩니다.
            - Acknowledgement Number는 2번에서 **S에게 전달받은 값에 1을 더한 값**이 담깁니다.
            - 이 시점부터 데이터 요청을 송신하고 응답을 받는 데에까지 걸리는 RTT(Rount Trip Time)을 계산할 수 있습니다.

    1번부터 3번까지 과정이 온전하게 완료되면 C와 S는 양방향 데이터 송신이 가능한 **`ESTABLISHED`** 상태가 됩니다.

    - ***Q. 4 way handshake의 과정에 대해 설명해주세요.***

        <p align="center"><img src="https://user-images.githubusercontent.com/62372281/209475536-55a69552-9cad-40d7-b92f-bfa0d83a72ee.png"></p>

        위 3way handshaked에서 수립된 커넥션은 더이상 데이터 전송이 필요하지 않을 때 소멸되어야 합니다. 이는 어떻게 소멸될까요? 여기선 **FIN 비트 세그먼트**를 활용합니다.

        (위를 예시로 C, S) 어느 쪽이든 연결를 해제하자고 요청할 수 있습니다. 이 때 먼저 요청한 쪽을 **`Active Closer`**, 이를 수신한 쪽을 **`Passive Closer`** 라고 부릅니다.

        1. Active Closer(하위 약칭, AC)는 Passive Closer(하위 약칭, PC)에게 '연결 해제'를 요청하며 **`FIN 비트 세그먼트`를 전송**합니다.
            - TCP Header의 Flags에는 `FIN` 비트가 표시됩니다.
            - 이 후 AC는 `FIN-WAIT1` 상태가 됩니다.
            - Sequence Number는 커넥션 수립 이후 전송된 데이터 양에 따라 달라집니다.
                - 만약 100 byte를 송신했다면 Sequence Number는 전송 바이트 양의 다음 값인 101이 됩니다.

        2. PC는 AC의 연결 해제 요청을 온전하게 전달 받았음을 표현하기 위해 **`ACK 비트 세그먼트`를 회신**합니다.
            - TCP Header의 Flags에는 `ACK` 비트가 표시됩니다.
            - 이 후 PC는 `CLOSE-WAIT1` 상태가 됩니다.
            - Sequence Number는 1번에서 **AC에게 전달받은 값에 1을 더한 값**이 담깁니다.
            -  AC는 PC의 회신을 받고, 연결 해제를 완료했다는 내용을 수신할 때까지 대기합니다. AC는 연결 해제 완료를 기다리는 `FIN-WAIT2` 상태가 됩니다.

        3. PC는 정상적으로 소켓을 종료하고 이를 표현하기 위해 **`FIN 비트 세그먼트`를 전송**합니다.
            - TCP Header의 Flags에는 `ACK` 비트가 표시됩니다.
            - PC는 AC가 응답(`ACK`)만 회신해준다면, 연결을 언제든 종료할 수 있는 상태인 `LAST-ACK` 상태가 됩니다.
            - 1번과 동일하게 계산된 Acknowledgement Number가 담깁니다.

        4. AC는 연결을 종료하겠다는 응답에 대해 회신하는 **`ACK비트 세그먼트`를 회신**합니다.
            - 서버는 ACK를 응답받은 후 연결을 해제합니다.
            - 이 때부터 AC는 혹여나 남았을 데이터를 수신하기 위해 특정 시간동안 `TIME-WAIT` 상태에서 대기한 뒤 연결을 해제합니다.
                - 일반적으로 TIME-WAIT 상태에서 대기하는 시간은 30초, 1분, 2분 입니다.

- ***Q. TCP는 왜 느릴까요 ? (1)***
    
    TCP는 데이터 전송 전 커넥션 수립 이전에 두 개의 패킷을 전송합니다. 바로 `SYN`과`SYN+ACK` 이죠. TCP 의 지연은 바로 이 구간, **SYN/SYN+ACK 수립 구간에서 지연이 많이 발생**합니다.
    
    TCP 세그먼트는 시퀀스 넘버, 데이터 무결성을 위한 헤더 체크섬을 가집니다. 이 때 TCP의 데이터 전송의 성공 보장 특성 때문에 자체적으로 전송 이상이 없는지 확인을 수행합니다. 만약 이상이 없으면 세그먼트 수신자는 확인 응답 패킷을 반환합니다. 만약 송신자가 확인 응답을 받지 못하면 문제가 있는 것으로 판단해 데이터를 다시 전송합니다.
    
    하지만 확인 응답 패킷은 크기가 너무 작아서 그냥 1개의 패킷에 아주 작은 부분만 채워 보내기에는 네트워크 비용이 아깝습니다. 따라서 보내려는 곳에 같이 가는 패킷이 있으면 살짝 얹어서 최대한 네트워크의 효율을 높히려 노력합니다. 
    
    - ***Q. 네트워크 효율을 높히는 히치하이킹 방법을 사용하는데도 느린 이유는 뭔가요?***
        
        우리는 앞서 말한 히치하이킹 방식을 **piggyback(편승)** 이라고 합니다. 하지만 요청과 응답으로만 이뤄지는 HTTP 특성 상 편승할 패킷이 비슷한 방향을 가려는 패킷을 찾는 과정때문에 지연이 발생합니다.
        
- ***Q. TCP는 왜 느릴까요 ? (2)***
    
    TCP는 커넥션의 생성 경과 시간에 따라 전송 속도가 달라집니다. 처음부터 커넥션의 최대 속도로 스트림을 전송하는 것이 아닌 점점 빨라지게 튜닝이 되는 방식입니다. 
    
    그 이유는 TCP가 처음 패킷을 보낼 때에는 정상 송신을 보장하지 못하기 때문입니다. 따라서 처음에는 커넥션 최대 속도를 제한해놓고, 데이터 전송이 성공했다는 것을 확인하면 그때부터 빨라지도록 제한을 풉니다. 처음에는 보낼 수 있는 패킷의 수를 제한하고, 성공하면 이걸 2개씩 늘려주는 방식입니다. 이걸 우리는 **slow start**라고 부릅니다. 이는 작은 traffic surge 방지 용도라고도 볼 수 있습니다.
    
- ***Q. TCP는 왜 느릴까요 ? (3)***
    
    일반적으로 TCP는 세그먼트 단위의 페이로드가 패킷에 담깁니다. 하지만 네트워크 효율을 고려한 네이글 알고리즘에 의해서 패킷 전송 전 많은 양의 TCP 데이터를 합치는 작업을 수행합니다. [RFC 896 - Congestion Control in IP/TCP Internetworks](https://www.rfc-editor.org/rfc/rfc896)
    
    하지만 네이글 알고리즘은 세그먼트의 데이터 양이 최대 크기에 도달하지 않으면 전송하지 않습니다. 따라서 만약 크기가 매우 작은 HTTP 메시지만 전송해야 한다면 세그먼트가 모두 찰 때까지 지연 시간이 꽤 클 것입니다.

- ***Q. TCP는 어떻게 데이터 전송량을 조절할까요?***

    혹시 약수터에서 물을 길러본 적이 있으신가요? 물을 뱉는 수도꼭지를 송신자, 물을 받는 물통을 수신자라고 생각해보시죠. 우린 물통에 물이 넘치지 않도록 물의 세기를 조절하곤 합니다. 하지만 네트워크 환경에서 비슷한 일이 일어난다면 우린 쏟아지는 데이터(물)의 양을 어떻게 조절할 수 있을까요?

    이 문제를 해결해 TCP의 `relialbe`함을 달성하게 만들어 주는 두 번째 요소는 바로 **`흐름 제어(Flow Control)`** 입니다. 흐름 제어는 일반적으로 송신과 수신 측의 데이터 처리 속도를 제어하여, 수신자의 처리 속도가 송신자의 전송 속도보다 느려 데이터가 과부화되는 현상을 방지합니다. **`흐름 제어(Flow Control)`** 를 구현하기 위해 TCP에서 사용하는 `Sliding Window`에 대해서 알아보겠습니다.

    <p align="center">
        <img src="https://user-images.githubusercontent.com/62372281/209979936-878ba57b-42b8-421e-ab6b-a20057379fcf.png">
    </p>

    `Sliding Window`는 **창틀(기전송 + 전송 예정 데이터를 표시하는 마커)이 미끄러지듯 조금씩 갱신되며, 해당 범위의 데이터를 전송**하는 형태로 동작합니다. `Window`는 송신하고자 하는 데이터(의 범위)를 마스킹하는 도구이며, 송신자는 3way handshake 시 서로의 버퍼 사이즈를 전달하는 과정을 통해 데이터가 전달되기 이전에 최초 크기를 초기화합니다. 버퍼 사이즈 외에도 3way handshake의 마지막 ACK 비트 세그먼트를 보내는 과정에서 추출 가능한 `RTT(Round Trip Time)` 등 여러 요소를 고려하여 **최종 window 사이즈(Receive Window, rwnd)를 결정**합니다.

    이 후 `window`에 포함된 데이터들이 전송되며, 수신자는 이에 대한 응답으로 `ACK 비트 세그먼트`를 전송합니다. `ACK 비트 세그먼트`에는 수신자의 버퍼 상태 등의 요소를 고려하여 계산된 **현재 가능한 window 크기(Current receive window)** 가 담깁니다.

    송신자는 최초 전달받은 `rwnd`만큼의 데이터를 전송하고, 회신한 `ACK 비트 세그먼트`에 맞춰 window를 우측으로 움직이며 전송되지 않은 데이터들을 추가로 전송합니다. 이렇게 window 크기에 맞춰 데이터 전송량을 조절하는 과정을 통해 **`흐름 제어(Flow Control)`** 가 가능해집니다. 이 때 송신자는 항상 `LastByteSent(전송한 바이트 크기) - LastByteAcked(ACK 회신을 받은 바이트 크기) <= ReceiveWindowAdvertised(전달받은 window 크기` 공식을 유지합니다.

    하지만 맹점이 하나 존재합니다. 수신자에게 장애가 발생하여 rwnd가 감소해 데이터를 전송할 수 없는 상태, 즉 rwnd가 0(Zero-window)이 된다면 어떻게 될까요? 송신자는 rwnd가 0이니 전송을 하지 못하고, 수신자는 장애가 회복되어도 갱신된 rwnd를 전송할 데이터가 오지 않을 겁니다. 데이터 전송에 데드락이 발생하게 됩니다.

    이를 방지하기 위해 TCP에서는 Zero-window 메시지를 받으면 `WindowProbe`라고 불리는 **작은 패킷을 주기적으로 전송하는 `Persist timer`를 가동**시킵니다. 이를 통해 장애가 회복되었을 때  송신자에게 데이터를 재전송받을 수 있게 됩니다.

- ***Q. TCP는 어떻게 오류를 확인할까요?***

  TCP는 TCP Header의 Checksum과 Retrasmission Timer를 활용해 오류를 확인하고 재전송합니다.

    - ***Q. TCP Header Checksum에 대해 설명해주세요.***

      TCP는 SYN-num, ACK-num을 통해 데이터 전송 순서를 보장합니다. 하지만 전송된 데이터가 잘못 되었는지는 어떻게 확인할 수 있을까요? 이 때 사용되는 것이 **TCP Header의 `checksum`** 입니다. `reliable`을 달성하는 첫 번째 요소죠. `Checksum`은 아래와 같은 순서로 계산됩니다.

      1. 송신자는 **TCP Header와 데이터를 16bit로 나누어 연속적인 블록 형태**로 만듭니다.
          - 만약 균등하게 16비트로 나눠지지 않는다면 추가 비트를 통해 남은 공간을 채웁니다.
      2. 나눠진 데이터 블록을 연속해서 더한 뒤, 최종 값에 1의 보수를 취합니다.
          - 연산 시 발생하는 carry(비트의 크기를 벗어난 값)는 Wrap Around 방식을 통해 계산된다.
      3. 수신자는 전달받은 데이터에 대해 1의 보수를 취하기 이전까지의 과정을 동일하게 진행한 뒤 전달받은 `checksum`을 더해줍니다.
      4. **송신자 `checksum` + 수신자 계산값의 합을 표현하는 비트가 모두 1이라면 정상**이라고 판단합니다.

    `Checksum`은 TCP Header와 데이터 뿐만 아니라 IP 수도 헤더(IP pseudo-header)도 사용되어 계산된다는 점을 주의해야 합니다. IP 수도 헤더는 출발지와 도착지 IP, 프로토콜 필드, TCP Header와 데이터의 길이도 포함되어 있습니다. 이런 IP 수도 헤더와 TCP Header + 데이터는 `checksum` 계산 시 단일 데이터 블록으로 취급되어 계산에 활용됩니다. 만약 이러한 계산을 통해 올바르지 않다고 판단된 패킷은 그대로 폐기됩니다. 이를 통해 TCP는 상대방에게 유효한 패킷만 전달되도록 할 수 있습니다.

    - ***Q. Retransmission Timer에 대해 설명해주세요.***
    
      Checksum은 패킷 자체에 물리적(?)으로 문제가 발생한 경우 사용됩니다. 하지만 Retrasmission Timer는 패킷이 전송된 후 ACK이 회신되지 않은 경우 사용됩니다. 내부적으로 RTT를 통해 결정되며, 계산하지 못하는 경우 `InitRTO`를 지정해 사용됩니다.

- ***Q. TCP는 네트워크에 문제가 생겼다는 것을 확인할까요?***

    예를 들어 수신자가 N명의 송신자에게 데이터를 수신한다 가정하겠습니다. 이 때 서로는 이더넷 케이블이나 셀룰러 링크와 같은 물리적 채널인 **`링크(link)`** 로 연결되어 있습니다. 각 송신자에게 최대 가용 바이트 크기를 전달하고, 송신자들은 데이터를 전송합니다.

    하지만 여러 송신자가 짧은 시간에 데이터를 전송하면 수신자는 `최대 가용 바이트 크기 X N(송신자 수)`만큼의 데이터를 수신하게 됩니다. 결국 중간 과정에서 오버플로우된 데이터(패킷)이 유실되는 결과를 초래합니다. TCP는 유실된 데이터를 재전송하는 프로토콜이기에 문제가 해결되지 않죠. 이러한 문제를 **`혼잡 문제 (Congestion problem)`** 이라고 합니다.
    
    인터넷은 탈중앙화 시스템이기에 문제가 발생해도 이를 처리하는 관리자가 없습니다. 따라서 우린 **패킷 손실**과 **RTT 시간 증가** 요소 등을 통해 혼잡 문제가 발생하고 있다는 것을 인지합니다. 데이터 전송이 혼잡으로 지연되면 링크의 대기열이 점차 채워지며, 결국 패킷이 손실됩니다.
    
    > _혼잡 제어에 대한 설명을 시작하기 전, 참고자료에선 네트워크 링크에 대한 요소를 설명하며, 내용은 아래와 같습니다. 여기서 링크는 패킷이 통과하는 파이프라인입니다._
    >
    >
    >![image](https://user-images.githubusercontent.com/62372281/210032550-5d748c47-ee79-4325-8add-215758f0c286.png)
    >
    > _지연시간 (millise) : 링크의 시작점부터 끝까지 하나의 패킷이 통과하는게 소요되는 시간으로, 파이프라인의 길이와 같습니다._
    > _대역폭 (megabits/sec) : 1초동안 링크를 통과할 수 있는 패킷의 개수로, 파이프라인의 너비와 같습니다._
    > _큐 : 링크가 가득 찬 경우 전송 대기중인 패킷을 저장하는 대기열의 크기_
    >
    > 우리가 기억해야 하는 요소는 특정 시점에 링크에 진입 가능한 바이트 수를 표시하는 `대역폭 X 지연시간= Bandwidth-delay product(BDP)`입니다.
    
    결국 혼잡 상태에서 패킷 손실과 RTT 시간을 고려하며 송신자는 수신자에게 매 전송마다 전달받는 `rwnd`와 자신의 네트워크 상황을 고려하여 계산한 Congestion Window 중 작은 값을 선택해 데이터를 전송합니다. 이 때 `cwnd`는 `rwnd`와 조금 다릅니다. `rwnd`가 수신자가 **수신할 수 있는 크기를 표현**했다면, `cwnd`는 **수신자에게 회신받은 `ACK 비트 세그먼트`없이 자신이 송신할 수 있는 크기를 표현**합니다.